# 01背包问题 / 完全背包问题

**题目**

| 序号/难度 | 名字 | 备注 |  |
| :--- | :--- | :--- | :--- |
| 494 | 目标和 | 01背包问题 | 没想到 |
| 416 | 分割等和子集 | 01背包问题（能看出来，一般都有标志说数组总和小于多少） | 防超时 |
| lint 91 | 最小调整代价 | 01背包问题变体 | 有难度 |
| lint 669 | 换硬币 | 完全背包问题 | 模板 |



**494.目标和**

**每一个num有两种选择 + or -，因为有一个特性：**

非负整数数组 + ****初始的数组的**和不会超过 1000** ==&gt; 暗示：01背包

有坑：S的范围可能会大于1000

```cpp
dp[i][j] += dp[i-1][j - nums[i-1]] + dp[i-1][j + nums[i-1]];
```

**最小调整代价**

给一个整数数组，调整每个数的大小，使得相邻的两个数的差不大于一个给定的整数target，调整每个数的代价为调整前后的差的绝对值，求调整代价之和最小是多少。

你可以假设数组中每个整数都是**正整数**，且小于等于**100**。

#### **样例：**

```text
输入:  [1,4,2,3], target=1 
输出:  2 
```

**解决：**

**关键：**已知每个整数范围\[1,100\]，那么对于每个元素，为了调整到该元素和与之相邻的元素的差不大于target，该元素调整的范围就在\[1,100\]

令dp\[i\]\[j\]表示元素A\[i\]=j时，A\[i\]与A\[i-1\]差值不大于target所需要付出的最小代价

当A\[i\]=j时，k在\[max\(1, j - target\)，min\(100, j + target\)\]范围内时

1.临界值：dp\[0\]\[j\] = abs\(j - A\[0\]\)

2.状态转移方程：dp\[i\]\[j\] = min\(dp\[i\]\[j\], dp\[i - 1\]\[k\] + abs\(j - A\[i\]\)\)

所有最后一位的可能解dp\[n-1\]\[i\]中的最小值，就是我们所求的最小代价

**换硬币**

给出不同面额的硬币以及一个总金额. 写一个方法来计算给出的总金额可以换取的最少的硬币数量. 如果已有硬币的任意组合均无法与总金额面额相等, 那么返回 ​-1​.

```text
输入：
[1, 2, 5]
11
输出： 3
解释： 11 = 5 + 5 + 1 
```

**解决：完全背包问题**

**dp\[i\]\[j\]** 表示使用前i个硬币，总金额为j时需要的最少硬币数量

```cpp
dp[i][j] = max(dp[i−1][j],dp[i−1][j−k∗coin[i]]+k) (0 ≤ k ∗ coin[i] ≤ j)
```

考虑到每次只用前面一层dp\[i-1\]的j前的部分，所以dp\[i\]\[j\]可以精简为dp\[j\]一维数组


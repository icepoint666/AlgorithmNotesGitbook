# 01背包问题 / 完全背包问题

**题目**

| 序号/难度 | 名字 | 备注 |  |
| :--- | :--- | :--- | :--- |
| 494 | 目标和 | 01背包问题 | 没想到 |
| 416 | 分割等和子集 | 01背包问题（能看出来，一般都有标志说数组总和小于多少） | 防超时 |
| lint 91 | 最小调整代价 | 01背包问题变体 | 有难度 |



**494.目标和**

**每一个num有两种选择 + or -，因为有一个特性：**

非负整数数组 + ****初始的数组的**和不会超过 1000** ==&gt; 暗示：01背包

有坑：S的范围可能会大于1000

```cpp
dp[i][j] += dp[i-1][j - nums[i-1]] + dp[i-1][j + nums[i-1]];
```

**最小调整代价**

给一个整数数组，调整每个数的大小，使得相邻的两个数的差不大于一个给定的整数target，调整每个数的代价为调整前后的差的绝对值，求调整代价之和最小是多少。

你可以假设数组中每个整数都是**正整数**，且小于等于**100**。

#### **样例：**

```text
输入:  [1,4,2,3], target=1 
输出:  2 
```

**解决：**

**关键：**已知每个整数范围\[1,100\]，那么对于每个元素，为了调整到该元素和与之相邻的元素的差不大于target，该元素调整的范围就在\[1,100\]

令dp\[i\]\[j\]表示元素A\[i\]=j时，A\[i\]与A\[i-1\]差值不大于target所需要付出的最小代价

当A\[i\]=j时，k在\[max\(1, j - target\)，min\(100, j + target\)\]范围内时

1.临界值：dp\[0\]\[j\] = abs\(j - A\[0\]\)

2.状态转移方程：dp\[i\]\[j\] = min\(dp\[i\]\[j\], dp\[i - 1\]\[k\] + abs\(j - A\[i\]\)\)

所有最后一位的可能解dp\[n-1\]\[i\]中的最小值，就是我们所求的最小代价


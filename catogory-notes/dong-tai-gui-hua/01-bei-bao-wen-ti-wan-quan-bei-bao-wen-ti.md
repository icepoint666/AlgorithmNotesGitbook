# 01背包问题 / 完全背包/ 多重背包问题

### 01背包核心 **（n件物品而不是n种物品）**

f\[i\]\[j\]表示背包容量为j，放前i个物品的最大价值。构建数组f\[n+1\]\[m+1\]。

v\[i\]表示第i-1个物品的价值，

w\[i\]表示第i-1个物品的质量。 

#### f\[i,j\] = max{ f\[i-1,j-w\[i-1\]\]+v\[i-1\]\( j &gt;= w\[i-1\] \),  f\[i-1,j\] }

f\[0\]\[j\] = 0, f\[i\]\[0\] = 0

* i&gt;=w\[j-1\]时，f\[i\]\[j\] = max\(f\[i-1\]\[j-\]+v\[j-1\],f\[i\]\[j-1\]\)
* i&lt;w\[j-1\]时，f\[i\]\[j\] = f\[i\]\[j-1\]

**空间压缩的01背包（滚动数组dp\[n+1\]\[2\]）**

```cpp
for(int j=1;j<=m;j++){//装前j个物品时 
    for(int i=1;i<=n;i++){ //背包容量为i时 
        if(i>=a[j-1]){
            f[i][1] = max(f[i-a[j-1]][0]+v[j-1],f[i][0]);
        } else {
            f[i][1] = f[i][0];
        }
    }
    for(int i=1;i<=n;i++){
        f[i][0]=f[i][1];
    }
}
```

### **完全背包（n种物品）**

**一维数组dp\[j\]容量为j的背包，最大价值**

**暴力：二维数组，三维循环**

**dp\[i\]\[j\]** 表示使用前i种物品，容量为j时需要的最少硬币数量

```cpp
dp[i][0] = 0;
for(int i = 0; i < N-1; i++)
    for(int j = 1; j <= V; j++)
        for(int k = 1; k * w[i] <= j; k++)
            dp[i][j] = max{dp[i-1][j], dp[i-1][j-k*w[i]]+k*v[i]}
return dp[N-1]
```

**优化：一维数组，二维循环**

考虑到每次只用前面一层dp\[i-1\]的j前的部分，所以dp\[i\]\[j\]可以精简为dp\[j\]一维数组

**对每一个v值，用01背包的思路计算每一个物品**

```cpp
dp[0] = 0;
for(int j = 1; j <= V; j++)
    for(int i = 0; i < N; i++)
        if(j >= w[i])
            dp[j] = max(dp[j], dp[j-w[i])+v[i]);
return dp[V]
        
```

### **多重背包（n种物品，各自有n\[i\]个）**

**二维数组，三维循环**

有N种物品和一个容量为V的背包。第i种物品最多有n\[i\]件，每件费用是c\[i\]，价值是w\[i\]

```cpp
dp[i][j] = max{dp[i - 1][v - k * c[i]] + k * w[i] | 0 <= k <= n[i]}
```

### **题目**

| 序号/难度 | 名字 | 备注 |  |
| :--- | :--- | :--- | :--- |
| 494 | 目标和 | 01背包问题 | 没想到 |
| 416 | 分割等和子集 | 01背包问题（能看出来，一般都有标志说数组总和小于多少） | 防超时 |
| lint 91 | 最小调整代价 | 01背包问题变体 | 有难度 |
| 322 | 换硬币 | 方法1：完全背包问题 方法2：贪心+dfs | 模板 |
| lint 89 | k数之和 | 类背包问题 |  |
| 阿里笔试 |  | 类背包的 |  |



**494.目标和**

**每一个num有两种选择 + or -，因为有一个特性：**

非负整数数组 + ****初始的数组的**和不会超过 1000** ==&gt; 暗示：01背包

有坑：S的范围可能会大于1000

```cpp
dp[i][j] += dp[i-1][j - nums[i-1]] + dp[i-1][j + nums[i-1]];
```

**lint 91 最小调整代价**

给一个整数数组，调整每个数的大小，使得相邻的两个数的差不大于一个给定的整数target，调整每个数的代价为调整前后的差的绝对值，求调整代价之和最小是多少。

你可以假设数组中每个整数都是**正整数**，且小于等于**100**。

#### **样例：**

```text
输入:  [1,4,2,3], target=1 
输出:  2 
```

**解决：**

**关键：**已知每个整数范围\[1,100\]，那么对于每个元素，为了调整到该元素和与之相邻的元素的差不大于target，该元素调整的范围就在\[1,100\]

令dp\[i\]\[j\]表示元素A\[i\]=j时，A\[i\]与A\[i-1\]差值不大于target所需要付出的最小代价

当A\[i\]=j时，k在\[max\(1, j - target\)，min\(100, j + target\)\]范围内时

1.临界值：dp\[0\]\[j\] = abs\(j - A\[0\]\)

2.状态转移方程：dp\[i\]\[j\] = min\(dp\[i\]\[j\], dp\[i - 1\]\[k\] + abs\(j - A\[i\]\)\)

所有最后一位的可能解dp\[n-1\]\[i\]中的最小值，就是我们所求的最小代价

**322 换硬币**

给出不同面额的硬币以及一个总金额. 写一个方法来计算给出的总金额可以换取的最少的硬币数量. 如果已有硬币的任意组合均无法与总金额面额相等, 那么返回 ​-1​.

```text
输入：
[1, 2, 5]
11
输出： 3
解释： 11 = 5 + 5 + 1 
```

**解决：完全背包问题**

**dp\[i\]\[j\]** 表示使用前i个硬币，总金额为j时需要的最少硬币数量

```cpp
dp[i][j] = max(dp[i−1][j],dp[i−1][j−k∗coin[i]]+k) (0 ≤ k ∗ coin[i] ≤ j)
```

考虑到每次只用前面一层dp\[i-1\]的j前的部分，所以dp\[i\]\[j\]可以精简为dp\[j\]一维数组

```cpp
int coinChange(vector<int>& coins, int amount) {
    int dp[amount+1];
    memset(dp, 0x3f, sizeof(dp));
    dp[0] = 0;
    for(int i = 1; i <= amount; i++)
        for(int j = 0; j < coins.size(); j++)
            if(i - coins[j] >= 0)
                dp[i] = min(dp[i], dp[i - coins[j]] + 1);
    if(dp[amount] > amount)return -1;
    return dp[amount];
}
```

**lint 89 k数之和**

给定 n 个不同的正整数，整数 k（k &lt;= n）以及一个目标数字 target。　

在这 n 个数里面找出 k 个数，使得这 k 个数的和等于目标数字，求问有多少种方案？

```text
输入:
List = [1,2,3,4]
k = 2
target = 5
输出: 2
说明: 1 + 4 = 2 + 3 = 5 
```

如果没有k的约束。我们可以发现，这题就可以转化为背包问题。利用n个正整数达到目标target。

有了k的约束之后，我们需要用额外的一维来维护使用的数字。

**dp\[i\]\[j\]\[t\]表示前i个数里选j个和为t的方案数\(最多选k个\)**

```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= k && j <= i; j++) {
        for (int t = 1; t <= target; t++) {
            f[i][j][t] = 0;
            if (t >= A[i - 1])
                f[i][j][t] = f[i - 1][j - 1][t - A[i - 1]];
            f[i][j][t] += f[i - 1][j][t];
        } // for t
    } // for j
} // for i
```


# 高楼扔鸡蛋：动态规划/递归

### **状态转移实在很巧妙！**

**leetcode 887**

 你面前有一栋从 1 到 `N` 共 `N` 层的楼，然后给你 `K` 个鸡蛋（`K` 至少为 1）。现在确定这栋楼存在楼层 `0 <= F <= N`，在这层楼将鸡蛋扔下去，鸡蛋**恰好没摔碎**（高于 `F` 的楼层都会碎，低于 `F` 的楼层都不会碎）。现在问你，**最坏**情况下，你**至少**要扔几次鸡蛋，才能**确定**这个楼层 `F` 呢？

注意：不能通过简单二分解决是因为**有固定鸡蛋个数的限制，**也就是说明，还是要从下往上来根据鸡蛋的个数来扔



**先来看一个子问题：有 2 个蛋，用一座 100 层的楼，要使用最少次数测试出蛋几层会碎（F）。 问第一次应该从几层扔。**

**思路一（错误）：二分法：**第一次50，错了之后从1开始，如果是49，那么就需要50次

**思路二（错误）：根号法：**两个鸡蛋就取根号，第一个鸡蛋找10，20，30，第二个再找个位，19次

**思路三（正确）：**

第一次找14个，如果破了，就在14个范围内找最多13次，如果没破，那么下一次找13个，然后缩小范围在12个里面找

所以这样最多次数每次都是在14个

这个14是怎么来的：14+13+12+...+1 &gt; 100



**核心思路：动态规划，关键找到状态转移（递归也其实是一样的道理）**

**问题转换！！：**

原本：有K个蛋，以及N层楼，需要多少次T能确定

现在：有K个蛋，以及可以扔T次，求至少可以确定多少层楼

**dp动态规划分析：**

状态：dp\[k\]\[t\]表示，有k个蛋以及还可以扔t次，求至少可以确定多少层楼

边界：

* **dp\[0\[t\]应该是1**（注意）
* dp\[k\]\[0\]用不到初始化为0
* dp\[1\]\[t\]应该是t+1
* dp\[t\]\[1\]应该是2（本质还是t+1）

转移：**子过程的思维**

**如果使用这一次的机会，相当于把任务给了两个子过程**

**碎了：就会少一个蛋，当然相对这次也少一次**

**没碎：就不少蛋，也同样少一次机会**

**但这一次的作用本质就是缩小范围，如果原来的确定范围在\[0,N\]那么子任务的范围只用\[0,M\]\(M,N\]**

dp\[k\]\[t\] = dp\[k-1\]\[t-1\]+dp\[k\]\[t-1\]

终止条件：dp\[k\]\[t\] &gt;= N+1 返回t （因为F取值范围是\[0, N\]闭区间，实际上有N+1层楼）

**示例：所以如果k=2的话**

dp\[2\]\[t\] = dp\[1\]\[t-1\] +dp\[2\]\[t-1\]

所以就可以推导出14，13，12的由来

```cpp
class Solution {
public:
    int superEggDrop(int K, int N) {
        int dp[K+1][N+1];
        int res;
        memset(dp, 0,sizeof(dp));
        for(int i = 1; i <= N; i++){
            dp[0][i] = 1;    //注意：如果没有蛋，但是这里要加一个1，因为存在就表示可以判断一层
            dp[1][i] = i+1;  //只有一个蛋，可以判断t次，那么就可以判断的楼层就是t+1，这里的层数是从0,1,2,3...开始算起的
        }
        for(int i = 1; i <= K; i++){
            for(int j = 1; j <= N; j++){
                if(j == 1)dp[i][j] = 2; //只有一次机会，那么只能判断两层0或者1层
                else dp[i][j] = dp[i-1][j-1] + dp[i][j-1]; 
                if(i == K && dp[i][j] >= N+1)res = j;
                if(dp[i][j] >= N+1)break;
            }
        }
        return res;
    }
};
```


# top K用堆来解决

如果对于**top K**问题，其中n &gt;&gt; k（n是远大于k的）用堆的复杂度是很好的

建堆时间复杂度 O\(n\) 然后 pop k 个点出来，时间复杂度 klogn 总共的时间复杂度 **O\(n+klogn\)**

**题目：**

示例题目：给定一些 ​points​ 和一个 ​origin​，从 ​points​ 中找到 ​k​ 个离 ​origin​ 最近的点。按照距离由小到大返回。如果两个点有相同距离，则按照x值来排序；若x值也相同，就再按照y值排序。

```text
输入: points = [[4,6],[4,7],[4,4],[2,5],[1,1]], origin = [0, 0], k = 3 
输出: [[1,1],[2,5],[4,4]]
```

比较堆的时候，自定义比较函数compare，实现的时候也可以用优先队列来实现


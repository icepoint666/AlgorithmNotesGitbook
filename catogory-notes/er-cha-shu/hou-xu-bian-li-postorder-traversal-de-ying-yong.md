# 后序遍历\(Postorder Traversal\)的应用

**汇总结果**

**Binary tree 的 post-order 遍历很实用，其遍历顺序的特点决定了其 bottom-up 的返回顺序，每次子树处理完了在当前节点上汇总结果**

**可以解决很多 和 subtree, tree path 相关的问题**

**在多叉树的情况下，也很容易扩展到各类的 search 问题：Leetcode351，安卓解锁模式**

* LCA问题：见LCA专题
* Find largest subtree: 见子树结构专题

### 题目

| 序号/难度 | 名字 | 备注 |  |
| :--- | :--- | :--- | :--- |
| 988 | 从叶节点开始的最小字符串 | 容易忽视字典序的特性 | 易错 |
| 1530 | 好叶子节点对的数量 | 经典后序遍历归并题 | 中等 |

**988. 从叶结点开始的最小字符串**

这道题很容易错的一个点就是：忽视**字典序特性**

**误以为可以 只要局部比较左右子树谁的字典序小，就接下来把谁送给父节点**

**这是不行的！**

示例：

a字典序比aba小，但是之后再经过两个父节点'b','z'后，abz比ababz的字典序大

如果这道题是从根节点到叶节点这样做是可以的

**做法1：归并所有结果（但其实这种做法复杂度很高）**

* **自底向上的return顺序 -- Post order**
* **子树计算完在当前节点汇总的计算 -- Merge Sort**

**做法2：dfs:** 当我们到达一个叶子节点的时候，我们翻转路径的字符串内容来创建一个候选答案。如果候选答案比当前答案要优秀，那么我们更新答案。

**1530. 好叶子节点对的数量**

给你二叉树的根节点 root 和一个整数 distance 。

如果二叉树中两个 叶 节点之间的 最短路径长度 小于或者等于 distance ，那它们就可以构成一组 好叶子节点对 。返回树中 好叶子节点对的数量 。

采用后续遍历的思想**dfs返回**

处理左，处理右，把左树右树归并一下，略去高度已经超过的节点，再继续往上


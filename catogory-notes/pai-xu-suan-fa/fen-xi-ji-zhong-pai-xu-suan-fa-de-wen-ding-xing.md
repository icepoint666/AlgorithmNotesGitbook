# 分析几种排序算法的稳定性

参考：[https://blog.csdn.net/Yeoman92/article/details/65452671](https://blog.csdn.net/Yeoman92/article/details/65452671)

稳定是指相同的两个元素会不会换顺序

#### **冒泡排序（Bubble Sort）** <a id="1&#x5192;&#x6CE1;&#x6392;&#x5E8F;bubble-sort"></a>

相同大小的元素是不会交换的，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种**稳定的**排序算法  

#### **选择排序（Selection sort）** <a id="2&#x9009;&#x62E9;&#x6392;&#x5E8F;selection-sort"></a>

举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序是**不稳定的**排序算法。

#### **插入排序（Insertion sort）** <a id="3&#x63D2;&#x5165;&#x6392;&#x5E8F;insertion-sort"></a>

插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是**稳定的**。

#### **快速排序（Quick sort）** <a id="4&#x5FEB;&#x901F;&#x6392;&#x5E8F;quick-sort"></a>

```text
        66  13  51  76  81  26  57  69  23
从右边找到23比66小，互换
        23  13  51  76  81  26  57  69  66
从左边找到76比66大，互换
        23  13  51  66  81  26  57  69  76
继续从右边找到57比66小，互换
        23  13  51  57  81  26  66  69  76
从左边查找，81比66大，互换
        23  13  51  57  66  26  81  69  76
从右边开始查找26比66小，互换
        23  13  51  57  26  66  81  69  76
此时66左边的数都比66小，66右边的数都比66大，完成一轮排序，对这个数的两边再递归上述方法。
```

交换就会把元素的稳定性打乱，所以快速排序是一个**不稳定的**排序算法，不稳定发生在中枢元素和a\[j\] 交换的时刻。

#### **归并排序（MERGE-SORT）** <a id="5&#x5F52;&#x5E76;&#x6392;&#x5E8F;merge-sort"></a>

合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。

#### **堆排序（Heap sort）** <a id="8&#x5806;&#x6392;&#x5E8F;heapsort-sort"></a>

堆排序的过程是从第n / 2开始和其子节点共3个值选择最大（大顶堆）或者最小（小顶堆），这3个元素之间的选择当然不会破坏稳定性。但当为n / 2 - 1， n / 2 - 2， … 1这些个父节点选择元素时，就会破坏稳定性


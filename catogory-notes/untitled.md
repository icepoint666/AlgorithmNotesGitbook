# 滑动窗口（Sliding Window）

滑动窗口类型的题目经常是用来执行数组或是链表上某个区间（窗口）上的操作。比如找最长的全为1的子数组长度。滑动窗口一般从第一个元素开始，一直往右边一个一个元素挪动。

当然了，根据题目要求，我们可能有固定窗口大小的情况，也有窗口的大小变化的情况。

**题目特征**

* 这个问题的输入是一些线性结构：比如链表呀，数组啊，字符串啊之类的
* 让你去求最长/最短子字符串或是某些特定的长度要求

**题目**

| 序号/难度 | 名字 | 备注 |
| :--- | :--- | :--- |
| 239（剑指offer59） | 滑动窗口最大值 | 单调栈\(deque实现）+ 窗口判定 |
| 76 | 最小覆盖子串 | 双指针（right右扫描，left左优化） |

#### 题目笔记

**239. 滑动窗口最大值**

长度k在长度n数组滑窗，找最大值

①暴力法：时间复杂度O\(nk\)

②双端队列+单调栈：时间复杂度O\(n\)

**本题关键点：\[3,4,1,2\]如果最新加入的4比之前的3要大，那么之前的就绝对不可能是最大值，就可以删了**

递减栈：如果新加入元素比尾部元素大的，删除掉尾部元素，然后继续检查删除

```cpp
while(!deq.empty() && nums[i] > nums[deq.back()]){
                deq.pop_back();
            }
```

双端队列，每次滑窗都要维护队头是否已经出区间

```cpp
if (!deq.empty() && deq.front() < i - k + 1) deq.pop_front()
```

**76. 最小覆盖子串**

易错：有可能字符串T有多个重复字符"AAA"，那么就不是单纯寻找最近字符位置那么简单（第一次做错了）

这个易错点决定了，不是单一记录字符是否存在的map那么简单，而是要有计数器的map

暴力法：远大于O\(N^2\)不适合

更好解法： O\(M+N\) **滑动窗口+左右指针的技巧**

1、我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 \[left, right\] 称为一个「窗口」。

2、我们先不断地增加 right 指针扩大窗口 \[left, right\]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。

3、此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 \[left, right\]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。

4、重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。

第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。

**针对于前面的易错：需要两个计数器：needs 和 window 相当于计数器，分别记录 T 中字符出现次数和窗口中的相应字符的出现次数。**

**实现：**用两个哈希表当作计数器解决。用一个哈希表 needs 记录字符串 t 中包含的字符及出现次数，用另一个哈希表 window 记录当前「窗口」中包含的字符及出现的次数，如果 window 包含所有 needs 中的键，且这些键对应的值都大于等于 needs 中的值，那么就可以知道当前「窗口」符合要求了，可以开始移动 left 指针了。

```cpp
unordered_map<char, int> window;
unordered_map<char, int> needs;
for (char c : t) needs[c]++;
```

更新：

```cpp
while (match == needs.size()) {
    if (right - left < minLen) {
        // 更新最小子串的位置和长度
        start = left;
        minLen = right - left;
    }
    ...
}
return minLen == INT_MAX ?
                "" : s.substr(start, minLen);
```


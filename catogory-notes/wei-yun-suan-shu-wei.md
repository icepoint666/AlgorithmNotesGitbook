# 位运算，数位

**题目**

| 序号/难度 | 名字 | 备注 |  |
| :--- | :--- | :--- | :--- |
| 剑指 Offer 56-I | 数字中出现一次的数 | 数字都出现了3次，只有它出现一次，找出它 | 中等 |
| 剑指 Offer 56-II | 数字中出现一次的数 | 数字都出现了2次，只有它俩出现一次，找出 | 中等 |
| 剑指 Offer 65 | 不用加减乘除的加法 | 理解加法位运算，补码的原理 | 记忆 |

**剑指 Offer 56 - I. 数组中数字出现的次数**

一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O\(n\)，空间复杂度是O\(1\)。

**异或运算的功能：**

* 交换律：p⊕q=q⊕p 
* 结合律：p⊕\(q⊕r\)=\(p⊕q\)⊕r 
* 恒等率：p⊕0=p 
* 归零率：p⊕p=0 

那么，如果有若干个数字进行异或操作：

$$
a{1} \oplus a{2} \oplus ... \oplus a_{n}
$$

我们可以根据 交换律、 结合律 将相同的数字优先两两进行异或运算。此时根据 归零率 ，每两个相同的数字都变成了 0，再根据 恒等率 ，把式子里所有的 0 去了，此时就只剩下只出现一次的那个数了！

本题关键：那么这一方法如何扩展到找出两个出现一次的数字呢？

如果我们可以把所有数字分成两组，使得：

* 两个只出现一次的数字在不同的组中；
* 相同的数字会被分到相同的组中。

我们根据异或的结果，如果有一位为1，那么就说明这两个数这个位不同，按照这个位来分成两组（分别异或，其实if else就可以实现）

```cpp
vector<int> singleNumbers(vector<int>& nums) {
    int nor = 0;
    for(auto &e :nums){
        nor = nor ^ e;
    }
    int i = 0;
    while(!((1<<i)&nor)){
        i++;
    }
    int nor_1 = 0, nor_2 = 0;
    for(auto &e: nums){
        if((1<<i)&e){
            nor_1 = nor_1 ^ e;
        }else{
            nor_2 = nor_2 ^ e;
        }
    }
    return vector<int>{nor_1, nor_2};
}
```

**剑指 Offer 56 - II. 数组中数字出现的次数 II**

 在一个数组 `nums` 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字

**解法：把每一位（题目范围说31位）个数统计一下如果整除3不等于0说明这个数有这一位**

```cpp
int singleNumber(vector<int>& nums) {
    int res = 0;
    for(int i = 0; i < 31; i++){
        int cnt = 0;
        for(auto &e:nums){
            if((1<<i)&e)cnt++;
        }
        if(cnt%3!=0)res+=(1<<i);
    }
    return res;
}
```

**剑指 Offer 65. 不用加减乘除做加法**

设两数字的二进制形式 a, b ，其求和 s = a + b，a\(i\)代表 a的二进制第 i 位，则分为以下四种情况：

| a\(i\) | b\(i\)  | 无进位和 n\(i\) | 进位 c\(i+1\)  |
| :--- | :--- | :--- | :--- |
| 0 | 0 | 0 | 0 |
| 1 | 0 | 1 | 0 |
| 0 | 1 | 1 | 0 |
| 1 | 1 | 0 | 1 |

观察发现，**无进位和** 与 **异或运算** 规律相同，**进位** 和 **与运算** 规律相同（并需左移一位）。

n = a ^ b                           非进位和：异或运算

c = a & b &lt;&lt; 1                  进位：与运算+左移一位 ​

（**这里如果不支持负数左移：改为c = \(unsigned int\)\(a&b\) &lt;&lt; 1**\)

s = a + b =&gt; s = n + c

**这里：每次无进位求和 + 每次得到的进位数--------我们需要不断重复这个过程，直到进位数为0为止**

**相当于从后往前不断进位运算的原理。**

\*\*\*\*

**补码的优势：**

**补码就是：正数 = 负数码取反 + 1**

Q ： 若数字 aa 和 bb 中有负数，则变成了减法，如何处理？

 A ： 在计算机系统中，数值一律用 补码 来表示和存储。**补码的优势**： **加法、减法可以统一处理**（**CPU只有加法器**）。因此，以上方法 同时适用于正数和负数的加法 。

```cpp
int add(int a, int b) {
    while(b != 0) { // 当进位为 0 时跳出
        int c = (a & b) << 1;  // c = 进位
        a ^= b; // a = 非进位和
        b = c; // b = 进位
    }
    return a;
}
```


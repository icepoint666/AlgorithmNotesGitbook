# 位运算，数位

**题目**

| 序号/难度 | 名字 | 备注 |  |
| :--- | :--- | :--- | :--- |
| 剑指 Offer 56-I | 数字中出现一次的数 | 数字都出现了3次，只有它出现一次，找出它 | 中等 |
| 剑指 Offer 56-II | 数字中出现一次的数 | 数字都出现了2次，只有它俩出现一次，找出 | 中等 |

**剑指 Offer 56 - I. 数组中数字出现的次数**

一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O\(n\)，空间复杂度是O\(1\)。

**异或运算的功能：**

* 交换律：p⊕q=q⊕p 
* 结合律：p⊕\(q⊕r\)=\(p⊕q\)⊕r 
* 恒等率：p⊕0=p 
* 归零率：p⊕p=0 

那么，如果有若干个数字进行异或操作：

$$
a{1} \oplus a{2} \oplus ... \oplus a_{n}
$$

我们可以根据 交换律、 结合律 将相同的数字优先两两进行异或运算。此时根据 归零率 ，每两个相同的数字都变成了 0，再根据 恒等率 ，把式子里所有的 0 去了，此时就只剩下只出现一次的那个数了！

本题关键：那么这一方法如何扩展到找出两个出现一次的数字呢？

如果我们可以把所有数字分成两组，使得：

* 两个只出现一次的数字在不同的组中；
* 相同的数字会被分到相同的组中。

我们根据异或的结果，如果有一位为1，那么就说明这两个数这个位不同，按照这个位来分成两组（分别异或，其实if else就可以实现）

```cpp
vector<int> singleNumbers(vector<int>& nums) {
    int nor = 0;
    for(auto &e :nums){
        nor = nor ^ e;
    }
    int i = 0;
    while(!((1<<i)&nor)){
        i++;
    }
    int nor_1 = 0, nor_2 = 0;
    for(auto &e: nums){
        if((1<<i)&e){
            nor_1 = nor_1 ^ e;
        }else{
            nor_2 = nor_2 ^ e;
        }
    }
    return vector<int>{nor_1, nor_2};
}
```

**剑指 Offer 56 - II. 数组中数字出现的次数 II**

 在一个数组 `nums` 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字

**解法：把每一位（题目范围说31位）个数统计一下如果整除3不等于0说明这个数有这一位**

```cpp
int singleNumber(vector<int>& nums) {
    int res = 0;
    for(int i = 0; i < 31; i++){
        int cnt = 0;
        for(auto &e:nums){
            if((1<<i)&e)cnt++;
        }
        if(cnt%3!=0)res+=(1<<i);
    }
    return res;
}
```


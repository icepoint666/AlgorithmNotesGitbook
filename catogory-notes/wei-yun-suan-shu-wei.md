# 位运算，数位

**负数的码：相反数补码+1**

|  | -**1** | -2 | -127 | -128 |
| :--- | :--- | :--- | :--- | :--- |
| 正数 | 00000001 | 00000010 | 01111111 | 10000000 |
| 正数的反码 | 11111110 | 11111101 | 10000000 | 01111111 |
| 正数的反码加1 | 11111111 | 11111110 | 10000001 | 10000000 |

**优势：应对加法不需要单独讨论**

**题目**

| 序号/难度 | 名字 | 备注 |  |
| :--- | :--- | :--- | :--- |
| 136 | 数字中出现一次的数 | 数字都出现了2次，只有它出现一次，找出它 | 简单 |
| 137/剑指 Offer 56-I | 数字中出现一次的数 | 数字都出现了2次，只有它俩出现一次，找出 | 中等 |
| 260/剑指 Offer 56-II | 数字中出现一次的数 | 数字都出现了3次，只有它出现一次，找出它 | 中等 |
| 剑指 Offer 65 | 不用加减乘除的加法 | 理解加法位运算，补码的原理 | 记忆 |
| 338 | 比特位计数 | 需要：O\(N\) 动态规划 | 中等 |
| 191 | 位1的个数 | 高效方法计算 | 记忆 |

**异或运算的功能：**

* 交换律：p⊕q=q⊕p 
* 结合律：p⊕\(q⊕r\)=\(p⊕q\)⊕r 
* 恒等率：p⊕0=p 
* 归零率：p⊕p=0 

那么，如果有若干个数字进行异或操作：

$$
a{1} \oplus a{2} \oplus ... \oplus a_{n}
$$

我们可以**根据 交换律、 结合律 将相同的数字优先两两进行异或运算**。

此时根据 **归零率** ，每两个相同的数字都变成了 0

再根据 **恒等率** ，把式子里所有的 0 去了，此时就只剩下只出现一次的那个数了！



**剑指 Offer 56 - I. 数组中数字出现的次数**

一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O\(n\)，空间复杂度是O\(1\)。

本题关键：那么这一方法如何扩展到找出两个出现一次的数字呢？

如果我们**可以把所有数字分成两组**，使得：

* 两个只出现一次的数字在不同的组中；
* 相同的数字会被分到相同的组中。

**根据异或的结果，如果有一位为1，那么就说明这两个数在这个位是不同的**，

**按照这个位来分成两组（分别异或，其实if else就可以实现）**

```cpp
vector<int> singleNumber(vector<int>& nums) {
    int ret = 0;
    for(auto &e: nums){
        ret = ret ^ e;
    }
    int split = -1;
    for(int i = 0; i < 32; i++){
        if(ret & (1 << i)){
            split = i;
            break;
        }
    }
    vector<int>ret_ = {0,0};
    for(auto& e: nums){
        if(e & (1 << split))
            ret_[0] = ret_[0] ^ e;
        else
            ret_[1] = ret_[1] ^ e;
    }
    return ret_;
}
```

**剑指 Offer 56 - II. 数组中数字出现的次数 II**

 在一个数组 `nums` 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字

**解法：把每一位（题目范围说31位）个数统计一下如果整除3不等于0说明这个数有这一位**

```cpp
int singleNumber(vector<int>& nums) {
    int res = 0;
    for(int i = 0; i < 31; i++){
        int cnt = 0;
        for(auto& e: nums){
            if((1 << i) & e)
                cnt++;
        }
        if(cnt % 3 != 0)
            res += (1 << i);
    }
    return res;
}
```

**剑指 Offer 65. 不用加减乘除做加法**

设两数字的二进制形式 a, b ，其求和 s = a + b，a\(i\)代表 a的二进制第 i 位，则分为以下四种情况：

| a\(i\) | b\(i\)  | 无进位和 n\(i\) | 进位 c\(i+1\)  |
| :--- | :--- | :--- | :--- |
| 0 | 0 | 0 | 0 |
| 1 | 0 | 1 | 0 |
| 0 | 1 | 1 | 0 |
| 1 | 1 | 0 | 1 |

观察发现，**无进位和** 与 **异或运算** 规律相同，**进位** 和 **与运算** 规律相同（并需左移一位）。

n = a ^ b                           非进位和：异或运算

c = a & b &lt;&lt; 1                  进位：与运算+左移一位 ​

（**这里如果不支持负数左移：改为c = \(unsigned int\)\(a&b\) &lt;&lt; 1**\)

s = a + b =&gt; s = n + c

**这里：每次无进位求和 + 每次得到的进位数--------我们需要不断重复这个过程，直到进位数为0为止**

**相当于从后往前不断进位运算的原理。**

\*\*\*\*

**补码的优势：加法、减法可以统一处理（不用单独讨论负数）**

**补码就是：正数 = 负数码取反 + 1**

Q ： 若数字 aa 和 bb 中有负数，则变成了减法，如何处理？

 A ： 在计算机系统中，数值一律用 补码 来表示和存储。**补码的优势**： **加法、减法可以统一处理**（**CPU只有加法器**）。因此，以上方法 同时适用于正数和负数的加法 。

```cpp
int add(int a, int b) {
    while(b != 0) { // 当进位为 0 时跳出
        int c = (unsigned int)(a & b) << 1;  // c = 进位
        a ^= b; // a = 非进位和
        b = c; // b = 进位
    }
    return a;
}
```

**338. 比特位计数**

给定一个非负整数 **num**。对于 **0 ≤ i ≤ num** 范围中的每个数字 **i** ，计算其二进制数中的 1 的数目并将它们作为数组返回。

**示例 :**

```text
输入: 2
输出: [0,1,1]
```

**解法：**

遵循可以通过最低有效位来获得状态转移函数。

观察x 和 x' = x / 2 的关系：

x = \(1001011101\)_2 = 605_

x' = \(100101110\)_2 = 302_

可以发现 x' 与 x 只有一位不同，这是因为x' 可以看做 x 移除最低有效位的结果。

这样，我们就有了下面的状态转移函数：

P\(x\) = P\(x / 2\) + \(x mod 2\) 

```cpp
vector<int> countBits(int num) {
    vector<int>res = {0};
    for(int i = 1; i <= num; i++){
        res.push_back(res[i >> 1] + (i & 1));
    }
    return res;
}
```

**191. 位1的个数**

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为[汉明重量](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F)）

```cpp
int hammingWeight(uint32_t n) {
    int sum = 0;
    while(n){
        n &= (n - 1);
        sum++;
    }
    return sum;
}
```


# 排列 next permutation

**题目**

| 序号/难度 | 名字 | 备注 |  |
| :--- | :--- | :--- | :--- |
| 31 | 下一个排列 | 明确下一个排列生成的策略是什么，思路清晰 | 记忆 |

**给定一个 整数数组/字符串 来表示排列，找出其之后的一个排列（原地修改）**

例1:

```text
输入:[1,3,2,3]
输出:[1,3,3,2]
```

例2:

```text
输入:[4,3,2,1]
输出:[1,2,3,4]
```

**解法：**

示例：1 11 12 4 7 6 5 3 2

* **step1 找**：从后往前寻找第一个非递增的下标i（注意相等也属于递增，所以要继续找）
  * 示例中从后往前寻找，2,3,5...，如果一直是逐渐增大的，则表明已经是最大的permutation了
  * 一旦出现一个**减少的下标**，例如7,4这里，那么后面的部分以及可以组成下一个排列
  * 本例中i 是 4对应的下标
* **step2 交换**：然后从i 往后找到比下标i 对应的数字大的 且值最小的那个，令它为k
  * 本例中找到了5
  * 交换i k，交换完毕 序列成为：1 11 12 5 7 6 4 3 2
* **step3 翻转**：然后把从i+1到整个数组最后一个反转
  * 1 11 12 5 2 3 4 6 7
  * 注意：如果一直没有找到下降的点\(i = -1\)，则全部逆转即可。（从完全的降序改为了升序）

时间复杂度：O\(N\)

```cpp
void nextPermutation(vector<int>& nums) {
    if(nums.size() == 0 || nums.size() == 1)return;
    //step 1: find
    int i = nums.size() - 2;
    while(i >= 0 && nums[i] >= nums[i+1])
        i--;
    //step 2: exchange
    int j;
    if(i >= 0){
        j = i + 1;
        while(j < nums.size() && nums[i] < nums[j]){
            j++;
        }
        j--;
        swap(nums[i], nums[j]);
    }
    //step 3: reverse
    j = nums.size() - 1;
    i = i + 1;
    while(i < j){
        swap(nums[i++], nums[j--]);
    }
    return;
}
```


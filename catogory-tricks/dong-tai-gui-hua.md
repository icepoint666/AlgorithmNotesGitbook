# 动态规划

**思考方式（3步）：**

* **寻找子问题（先解决子问题，子问题本质一定要与总问题等价，定义dp）**
* **子问题如何转移成总问题（定义状态转移方程）**
* **初始化，最简单子问题定义**

**问题分解：拿石子合并问题来想**

dp\[i,j\]表示第i个石子到第j个石子合并的最小代价，dp\[1,n\]表示求解的目标

dp\[i,j\] = dp\[i,k\] + dp\[k+1,j\] + sum\[j\] - sum\[i-1\] \(sum表示前缀和）



以小跳蛙为例，一次可以跳一格或者两个，问跳到n阶楼梯有几种可能跳法

* 初始条件：dp\[0\] = 1（不太严谨），dp\[1\] = 1, dp\[2\] = 2\(如果dp\[0\]确定的话，可以省略）
* 状态转移：dp\[i\] = dp\[i-1\] +dp\[i-2\]

模板：

```cpp
int numWays(int n) {
    int dp[max(n+1, 2)];
    //memset(dp, 0, sizeof(dp)); 
    // 初始化数组，其实这个问题没必要初始化
    dp[0] = 1;
    dp[1] = 1;
    for(int i = 2; i <= n; ++i){
        dp[i] = (dp[i-1] + dp[i-2])%(int)(1e9+7); //如果数过大，需要取模，因为单纯1e9+7：leetcode会报错
    }
    return dp[n];
}
```

**子序列问题：很经常用dp来解决**

**一维dp:最长上升子序列**

**二维dp:最长回文子序列，最长回文子串**


# 海量数据场景题

### 常用做法

* hash+分治存在一对小文件
* 堆排序 topK （找K个最大值，用含K个节点的最小堆，复杂度：KlogN）
* bitmap （判断有数字重复或者数字是否在其中存在）



### \*\*\*\*

### **1.系统文件日志几千万条，提取出某日访问百度次数最多的那个IP。**

**算法思想：** 分而治之+Hash

①.IP地址最多有2^32=4G种取值情况，而且因为数据量比较大，所以不能完全加载到内存中用map处理；  
②.可以考虑采用“分而治之”的思想，**按照IP地址的Hash\(IP\)%1024值**，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址；  
③.对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时 记录当前出现次数最多的那个IP地址；**（用哈希处理了可以保证，同IP的记录只会出在一个文件中）**  
④.可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体 上出现次数最多的IP；

### 2.文件里2亿个数，找到最大的100个数

**算法思想：** 分而治之+Hash

如果数是固定字节存一个数的话，就可以取哈希 分出来100组 Hash\(num\)%100

每组利用堆排序找到top100

合并的时候再把100组的top100合成最大的100

### **3.搜索引擎会通过日志文件把用户每次检索使用的所有检索串 都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但 如果除去重复后，不超过3百万个。一个查询串的重复度越高， 说明查询它的用户越多，也就是越热门。），请你统计最热门的 10个查询串，要求使用的内存不能超过1G。**

可以在内存中处理，典型的Top K算法  
**算法思想：** hashmap+堆

先对这批海量数据预处理，在O（N）的时间内用Hash表完成统计；借助堆这个数据结构，找出Top K，时间复杂度为O\(N\*logK\)。

**算法思想：**采用trie树

关键字域存该查询串出现的次数，没有出现为0。最后用10个元 素的最小推来对出现频率进行排序。

### **4.有一个1G大小的一个文件，里面每一行是一个词，词的大小 不超过16字节，内存限制大小是1M。返回频数最高的100个词。**

**算法思想：** 分而治之 + hash统计 + 堆排序

> ①.顺序读文件中，对于每个词x，取hash\(x\)%5000，然后按照该值存到5000个小文 件（记为x0,x1,...x4999）中。这样每个文件大概是200k左右。如果其中的有的文件 超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小 都不超过1M。  
> ②.对每个小文件，采用trie树/hash\_map等统计每个文件中出现的词以及相应的频 率。  
> ③.取出出现频率最大的100个词（可以用含100个结点的最小堆）后，再把100个词 及相应的频率存入文件，这样又得到了5000个文件。最后就是把这5000个文件进行归并（类似于归并排序）的过程了。

### **5.有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的 频度排序。**

**方案1：算法思想：分而治之 + hash统计 + 堆排序**  
顺序读取10个文件，按照hash\(query\)%10的结果将query写入到另外10个文件中。 这样新生成的文件每个的大小大约也1G，大于1G继续按照上述思路分。  
找一台内存在2G左右的机器，依次对用hash\_map\(query, query\_count\)来统计每个 query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的 query和对应的query\_cout输出到文件中。这样得到了10个排好序的文件（记为）。  
对这10个文件进行归并排序（内排序与外排序相结合）。

**方案2： 算法思想：hashmap+堆**  
一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query， 一次性就可以加入到内存了。这样，我们就可以采用trie树/hash\_map等直接来统计 每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。

### **6.给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url**

**方案1：** 可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所 以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。

**算法思想：** 分而治之 + hash统计

遍历文件a，对每个url求取hash\(url\)%1000，然后根据所取得的值将url分别存储到 1000个小文件（记为a0,a1,...,a999）中。这样每个小文件的大约为300M。

遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为 b0,b1,...,b999）。这样处理后，所有可能相同的url都在对应的小文件 （a0vsb0,a1vsb1,...,a999vsb999）中，不对应的小文件不可能有相同的url。然后 我们只要求出1000对小文件中相同的url即可。

求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash\_set中。然后 遍历另一个小文件的每个url，看其是否在刚才构建的hash\_set中，如果是，那么就 是共同的url，存到文件里面就可以了。

**方案2：** 如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示 340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读 取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的 url（注意会有一定的错误率）。

### **7.在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这 2.5亿个整数。**

**算法思想：bitmap**

采用**2-Bitmap**（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次， 11无意义）进行，**包含所有整数的bitmap**，**共需内存2^32 \* 2 bit=1 GB内存**，还可以接受。然后扫描这2.5亿 个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完 事后，查看bitmap，把对应位是01的整数输出即可。

### **8.给40亿个不重复的unsigned int的整数，没排过序的，然后 再给一个数，如何快速判断这个数是否在那40亿个数当中？**

**方案1：** 申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设 置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示 不存在。

**方案2：** 因为2^32为40亿多，所以给定一个数可能在，也可能不在其中；

这里我们把40亿个数中的每一个用32位的二进制来表示

假设这40亿个数开始放在一个文件中。

**然后将这40亿个数分成两类:**

> 1.最高位为0  
> 2.最高位为1

并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;=20亿，而另一个 &gt;=20亿（这相当于折半了）；

与要查找的数的最高位比较并接着进入相应的文件再查找

**再然后把这个文件为又分成两类:**

> 1.次最高位为0  
> 2.次最高位为1

并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;=10亿，而另一个 &gt;=10亿（这相当于折半了）；




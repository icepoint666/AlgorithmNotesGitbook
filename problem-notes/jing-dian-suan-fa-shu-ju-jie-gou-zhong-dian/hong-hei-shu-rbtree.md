# 红黑树\(rbtree\)

### 应用场景

* C++STL中的std::map, std::set\(又叫树状数组，有序集合\)\(std::unordered\_map与std::unordered\_set都是哈希表\)
* nginx用来管理timer
* epoll中用红黑树管理事件块（文件描述符）
* Linux进程调度Completely Fair Scheduler用红黑树管理进程控制块

### 提出目的

红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况。

### 特性（规则）

* 1.具有二叉查找树的特点。
* 2.节点是红色或者黑色，根节点是黑色，叶子节点都是黑色的空节点（叶子节点不存数据）
* 3.任何相邻的节点都不能同时为红色
  * 也就是说，红色节点是被黑色节点隔开的。
  * 或者说，每个红色节点必须有两个黑色的子节点
* 4.从任一节点到其每个叶子\(NIL\)的所有简单路径都包含相同数目的黑色节点

事实上，如上所有的规则都只想做一件事，让二叉树尽可能的平衡。

不可能出现两个连续的红色节点，也就是说支树上最多是红黑交替的情况，即代表红黑树中最长路径最多是最短路径的两倍。

### 为什么有了平衡树还需要红黑树

平衡树解决了二叉查找树退化为近似链表的缺点，能够把查找时间控制在 O\(logn\)，不过却不是最佳的，因为平衡树要求**每个节点的左子树和右子树的高度差至多等于1**，这个要求实在是太严了，导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的这个规则， 进而我们都需要通过**左旋**和**右旋**来进行调整，使之再次成为一颗符合要求的平衡树。

 红黑树在插入、删除等操作，**不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整**，这也是我们为什么大多数情况下使用红黑树的原因。

单单在**查找方面的效率的话，平衡树比红黑树快**。

所以，我们也可以说，**红黑树是一种不大严格的平衡树**。也可以说是一个**折中方案**。

### 平衡树与红黑树性能分析






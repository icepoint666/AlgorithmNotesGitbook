# 红黑树\(rbtree\)

### 应用场景

* C++STL中的std::map, std::set\(又叫树状数组，有序集合\)\(std::unordered\_map与std::unordered\_set都是哈希表\)
* nginx用来管理timer
* epoll中用红黑树管理事件块（文件描述符）
* Linux进程调度Completely Fair Scheduler用红黑树管理进程控制块

### 提出目的

红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况。

### 特性（规则）

* 1.具有二叉查找树的特点。
* 2.节点是红色或者黑色，根节点是黑色，叶子节点都是黑色的空节点（叶子节点不存数据）
* 3.任何相邻的节点都不能同时为红色
  * 也就是说，红色节点是被黑色节点隔开的。
  * 或者说，每个红色节点必须有两个黑色的子节点
* 4.从任一节点到其每个叶子\(NIL\)的所有简单路径都包含相同数目的黑色节点
  * 所以决定了红黑树中最长路径最多是最短路径的两倍

事实上，如上所有的规则都只想做一件事，让二叉树尽可能的平衡。

不可能出现两个连续的红色节点，也就是说支树上最多是红黑交替的情况，即代表红黑树中最长路径最多是最短路径的两倍。

示例：下图就是红黑树，最短路径是55-45，也就是2，最长路径是55-107，也就是4，刚好符合标准

![](../../../.gitbook/assets/v2-778b52587b43b506055a4062076665d0_720w.jpg)

### 为什么有了平衡树还需要红黑树

**平衡树**解决了二叉查找树退化为近似链表的缺点，能够把查找时间控制在 O\(logn\)，不过却不是最佳的，因为平衡树要求**每个节点的左子树和右子树的高度差至多等于1**，这个要求实在是太严了，导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的这个规则， 进而我们都需要通过**左旋**和**右旋**来进行调整，使之再次成为一颗符合要求的平衡树。

 **红黑树在插入、删除**等操作，**不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整**，这也是我们为什么大多数情况下使用红黑树的原因。

单单在**查找方面的效率的话，平衡树比红黑树快**。

**红黑树不用严格控制高度，使得插入，删除效率更高。**

所以，我们也可以说，**红黑树是一种不大严格的平衡树**。也可以说是一个**折中方案**。

### 红黑树的插入

与平衡二叉树是类似的，也需要先按照二叉搜索树的原则插入，之后维护平衡

**示例：**\(其中一种可能的示例，并不代表通例）刚插入的节点为X，它的父节点为N，祖父节点为P，N的兄弟节点为U，下图列举了一种可能的情况：（需要分多种情况去讨论）

注意：这里P只是一个节点，并不是根节点

其中红底的代表红节点，黑底的代表黑节点，白底的代表颜色未知的节点（即可黑可红）

![](../../../.gitbook/assets/v2-3ddada4ec2cc094f6e6d9dddcd562f64_720w.jpg)

**红黑树中规定，新插入的节点一定是红色**

**情况1：** **N为黑色**

这种情况最简单，不需要任何调整，插入红色节点并不影响路径上黑色节点的数量，因为N为黑色，也可以保证不会出现连续红色

**情况2：** **N为红色**

时出现了X和N为两个连续的红节点，需要调整树，让它符合红黑树的特征

情况2.1：N为P的左节点，X为N的左节点 

情况2.2：N为P的左节点，X为N的右节点

情况2.3：N为P的右节点，X为N的右节点

情况2.4：N为P的右节点，X为N的左节点

其实前面两种和后面两种是成镜像的，也就是说分析前两种，后面两种的操作可以效仿前两种

可以做的操作有：左旋，右旋，节点颜色修改等，从而让树重新符合红黑树的特征

**情况2.1：N为P的左节点，X为N的左节点** 

![](../../../.gitbook/assets/v2-662d393e065af14e4ed0403313afbb60_720w.jpg)

这种情况我们就需要分析U节点的颜色

**情况2.1.1：U节点为红色**

直接把N和U全部设置为黑色，把P设置为红色即可

![](../../../.gitbook/assets/v2-b0e2f86d681d3d5d56d7ec6cc0da2ed9_720w.jpg)

所以插入后，假设P节点，之前有a个黑色节点，在到达X,1,2,3这四个节点的时候，经过黑色节点的数量如下（这时候还没有按照上述操作改变）：

```text
X节点：a + 1
1节点：a + 2
2节点：a + 2
3节点：a + 2
```

在改变之后

```text
X节点：a + 1
1节点：a + 2
2节点：a + 2
3节点：a + 2
```

所以改变前后依然符合红黑树的特征：也就是经过路径的黑色节点个数相等

**情况2.1.2：U节点为黑色**

首先对**P节点进行右旋**，然后**交换N和P节点的颜色**

![](../../../.gitbook/assets/v2-b0e2f86d681d3d5d56d7ec6cc0da2ed9_720w%20%281%29.jpg)

同样按照上述操作，设到达P节点之前，有a个黑色节点。在改变之前，在到达X,1,2,3这四个节点的时候，经过黑色节点的数量如下，\(因为2，3节点的颜色未知，所以用d2,d3代表。比如说如果2为黑，d2则为1，否则为0\)：

```text
X节点：a + 1
1节点：a + 2
2节点：a + 2 + d2
3节点：a + 2 + d3
```

改变之后

```text
X节点：a + 1
1节点：a + 2
2节点：a + 2 + d2
3节点：a + 2 + d3
```

可以发现改变之后还是符合红黑树的特征

**情况2.2：N为P的左节点，X为N的右节点**

![](../../../.gitbook/assets/v2-b0e2f86d681d3d5d56d7ec6cc0da2ed9_720w%20%282%29.jpg)

首先左旋N节点

同理分析在改变之前，在到达1,2,3,4,5这五个节点的时候，经过黑色节点的数量如下

```text
1节点：a + 2
2节点：a + 2 + d2
3节点：a + 2 + d3
4节点：a + 2
5节点：a + 2
```

改变之后

```text
1节点：a + 2
2节点：a + 2 + d2
3节点：a + 2 + d3
4节点：a + 2
5节点：a + 2
```

可以看出，并没有改变支路上黑节点的数量。但是N,X还是两个连续的红节点，还要继续操作。观察到**上图被红色方框圈出来的东西**发现，它就是之前**情况2.1：N为P的左节点，X为N的左节点**的那种情况，所以可以转到对应的步骤处理。

### 红黑树理解与性能分析

红黑树属于**平衡二叉树**。 说它**不严格**是因为它**不是严格控制左、右子树高度或节点数之差小于等于1**。 但红黑树高度依然是**平均log\(n\)**，且**最坏情况高度不会超过2log\(n\)**



（有非官方实验表明，**优化过的AVL树**与**Linux的rbtree**在插入删除性能上差异也没有那么明显）






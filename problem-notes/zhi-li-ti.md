# 智力题 / 博弈论

**1.两种药丸A和B，外表完全一样，也没法通过气味甄别，小明有两颗A也有两颗B，但把它们弄混了，小明每次需要服用半颗A半颗B，怎么办**

（四等分切割）

**2.1000桶水，其中一桶有毒，猪喝毒水后会在15分钟内死去，想用一个小时找到这桶毒水，至少需要几头猪？**

**naive的想法：**每桶水都用2进制编号，1000&lt;1024，所以十位数就够了，也就是10头猪，但是这只需要15分钟，显然这种办法不是最好的（因为这里每个猪是**二进制**，**中毒和没中毒**）

**正确想法：**其实1个小时内每头猪最多提供更多的信息：

0-15分钟死/15-30分钟死/30-45分钟死/45-60分钟死/不死。5种

所以可以把猪想成是一个**五进制**5^5&gt;1000,所以**5只猪够的**

因为我们只在0，15，30，45分钟喂水，所以我们将这几个时间点记成第一二三四轮。5头猪称为1号猪2号猪3号猪4号猪5号猪。把1-1000号水按照5进制编号。

第一轮：喂1号猪5进制下末位数是0的水，喂2号猪5进制下倒数第二位数是0的水，喂3号猪5进制下倒数第三位数是0的水，喂4号猪5进制下倒数第四位数是0的水，喂5号猪5进制下倒数第五位数是0的水。

第二轮：开始前发现3号猪和5号猪死了。所以有毒的水的编号是0\_0\_\_. 喂1号猪5进制下末位数是1的水，喂2号猪5进制下倒数第二位数是1的水，喂4号猪5进制下倒数第四位数是1的水。

第三轮：开始前发现2号猪死了。所以有毒的水编号是0\_01\_. 喂1号猪5进制下末位数是2的水，喂4号猪5进制下倒数第二位数是2的水。

第四轮：开始前发现1号和4号还活着。喂1号猪5进制下末位数是3的水，喂4号猪5进制下倒数第四位数是3的水。

到60分钟的时候，发现1号死了，4号还活着。所以有毒的水的编号是04013。这个数在10进制下是508，所以是508号桶水有毒。  
  
链接：https://www.zhihu.com/question/60227816/answer/175455729

**3. Nim游戏（不同动态规划去做）**

你和你的朋友面前有一堆石子，你们轮流拿，一次至少拿一颗，最多拿三颗，谁拿走最后一颗石子谁获胜。假设你们都很聪明，由你第一个开始拿，请你写一个算法，输入一个正整数 n，返回你是否能赢（true 或 false）。

  
**我们解决这种问题的思路一般都是反着思考**：

如果我能赢，那么最后轮到我取石子的时候必须要剩下 1~3 颗石子，这样我才能一把拿完。

如何营造这样的一个局面呢？显然，如果对手拿的时候只剩 4 颗石子，那么无论他怎么拿，总会剩下 1~3 颗石子，我就能赢。

所以**只要开始石子不是4的倍数，那么无论是4n+1,4n+2,4n+3总能控制到让对方拿的时候变成4的倍数，如果开始是4的倍数，那就我方必输**

```cpp
bool canWinNim(int n) {
    return n % 4 != 0;
}
```

**4. 石头游戏**

你和你的朋友面前有一排石头堆，用一个数组 piles 表示，piles\[i\] 表示第 i 堆石子有多少个。你们轮流拿石头，一次拿一堆，但是只能拿走最左边或者最右边的石头堆。所有石头被拿完后，谁拥有的石头多，谁获胜。

**假设你们都很聪明**，由你第一个开始拿，请你写一个算法，输入一个数组 piles，返回你是否能赢（true 或 false）。

并不是简单的挑两边数字大的选，piles=\[2, 1, 9, 5\]，这也是强调双方都很聪明的原因，算法也是求最优决策过程下你是否能赢。

**其实这道题是先手必胜**

因为题目有两个条件很重要：一是石头总共有偶数堆，石头的总数是奇数。这两个看似增加游戏公平性的条件，反而使该游戏成为了一个割韭菜游戏

我们把这四堆石头按索引的奇偶分为两组，即第 1、3 堆和第 2、4 堆，那么这两组石头的数量一定不同，

而作为第一个拿石头的人，你可以控制自己拿到所有偶数堆，或者所有的奇数堆。

你最开始可以选择第 1 堆或第 4 堆。如果你想要偶数堆，你就拿第 4 堆，这样留给对手的选择只有第 1、3 堆，他不管怎么拿，第 2 堆又会暴露出来，你就可以拿。同理，如果你想拿奇数堆，你就拿第 1 堆，留给对手的只有第 2、4 堆，他不管怎么拿，第 3 堆又给你暴露出来了。

**在第一步就观察好，奇数堆的石头总数多，还是偶数堆的石头总数多，然后步步为营，就一切尽在掌控之中了**

#### **5.**电灯开关问题

**题目：**

有 n 盏电灯，最开始时都是关着的。现在要进行 n 轮操作：

第 1 轮操作是把每一盏电灯的开关按一下（全部打开）。

第 2 轮操作是把每两盏灯的开关按一下（就是按第 2，4，6... 盏灯的开关，它们被关闭）。

第 3 轮操作是把每三盏灯的开关按一下（就是按第 3，6，9... 盏灯的开关，有的被关闭，比如 3，有的被打开，比如 6）...

如此往复，直到第 n 轮，即只按一下第 n 盏灯的开关。

现在给你输入一个正整数 n 代表电灯的个数，问你经过 n 轮操作后，这些电灯有多少盏是亮的？

**当然可以通过bool数组模拟来输出结果，但是这太麻烦了**

**答案：**

```cpp
int bulbSwitch(int n) {
    return (int)sqrt(n);
}
```

**思考：**

与因子有关，例如n = 6：第6盏灯，在第 1、2、3、6 轮会被按

6 = 1 x 6 = 2 x 3，因子一般都是成对出现，也就是**开关被按都是偶数次**

但是有特殊情况，比如说总共有 16 盏灯，那么第 16 盏灯会被按几次?`16=1x16=2x8=4x4`

因子 4 重复出现，所以第 16 盏灯会被按 5 次，奇数次

**所以**  16 盏灯，我们求 16 的平方根，等于 4，这就说明最后会有 4 盏灯亮着，它们分别是第 `1x1=1` 盏、第 `2x2=4` 盏、第 `3x3=9` 盏和第 `4x4=16` 盏。

**6.硬币排成线**

有 n 个硬币排成一条线。两个参赛者轮流从右边依次拿走 1 或 2 个硬币，直到没有硬币为止。拿到最后一枚硬币的人获胜。

请判定 **先手玩家** 必胜还是必败?

若必胜, 返回 true, 否则返回 false.

**解法：枚举**

* n = 1，n = 2必然是**先拿的获胜**
* n = 3必然是**后拿的获胜**
* n = 4，取1转换为n = 3，所以必然是**先拿的获胜**
* n = 5，取2转换为n = 3，所以必然是**先拿的获胜**
* n = 6，无论取1 or 2都会后手被转化为n = 3，必然是**后拿的获胜**
* **...规律如此**





